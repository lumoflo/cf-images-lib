{"version":3,"sources":["/Users/prakharshukla/Code/github/lumoflo-org/cf-images-lib/dist/index.js","../index.ts"],"names":["__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__export","target","all","name","get","enumerable","__copyProps","to","from","except","desc","key","call","__toESM","mod","isNodeMode","__esModule","value","__toCommonJS","cf_images_lib_exports","default","Uploader","module","exports","import_form_data","require","import_uuid","import_zod","axios","ResultSchema","z","object","id","string","filename","uploaded","requireSignedURLs","boolean","variants","array","ResponseSchema","result","success","errors","unknown","messages","CF_ACCOUNT_ID","CF_API_TOKEN","fromBase64","base64Text","fileExtension","uuidv4","Promise","resolve","reject","Error","includes","formData","FormData","append","Buffer","sendRequest","then","data","parsedData","parse","catch","err","toString","options","method","url","headers","Authorization","request","fromURL"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// index.ts\nvar cf_images_lib_exports = {};\n__export(cf_images_lib_exports, {\n  default: () => Uploader\n});\nmodule.exports = __toCommonJS(cf_images_lib_exports);\nvar import_form_data = __toESM(require(\"form-data\"));\nvar import_uuid = require(\"uuid\");\nvar import_zod = require(\"zod\");\nvar axios = require(\"axios\").default;\nvar ResultSchema = import_zod.z.object({\n  id: import_zod.z.string(),\n  filename: import_zod.z.string(),\n  uploaded: import_zod.z.string(),\n  // Assuming date string format, you can specify a Date schema if required\n  requireSignedURLs: import_zod.z.boolean(),\n  variants: import_zod.z.array(import_zod.z.string())\n});\nvar ResponseSchema = import_zod.z.object({\n  result: ResultSchema,\n  success: import_zod.z.boolean(),\n  errors: import_zod.z.array(import_zod.z.unknown()),\n  // Assuming errors can be of any type\n  messages: import_zod.z.array(import_zod.z.unknown())\n  // Assuming messages can be of any type\n});\nvar Uploader = class {\n  constructor(CF_ACCOUNT_ID, CF_API_TOKEN) {\n    this.fromBase64 = async (base64Text, filename = (0, import_uuid.v4)(), fileExtension = \"png\") => {\n      return new Promise((resolve, reject) => {\n        if (!base64Text) {\n          reject(new Error(\"base64Text cannot be empty\"));\n          return;\n        }\n        if (base64Text.includes(\"base64\")) {\n          reject(new Error(\"Remove data:***/***;base64 tag from input.\"));\n          return;\n        }\n        const formData = new import_form_data.default();\n        formData.append(\n          \"file\",\n          Buffer.from(base64Text, \"base64\"),\n          `${filename}.${fileExtension}`\n        );\n        this.sendRequest(formData).then((data) => {\n          const parsedData = ResponseSchema.parse(data);\n          resolve(parsedData);\n        }).catch((err) => {\n          reject(new Error(err?.toString()));\n        });\n      });\n    };\n    this.sendRequest = async (formData) => {\n      const options = {\n        method: \"POST\",\n        url: `https://api.cloudflare.com/client/v4/accounts/${this.CF_ACCOUNT_ID}/images/v1`,\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n          Authorization: `Bearer ${this.CF_API_TOKEN}`\n        },\n        data: formData\n      };\n      return (await axios.request(options))?.data;\n    };\n    this.fromURL = async (url) => {\n      return new Promise((resolve, reject) => {\n        if (!url) {\n          reject(new Error(\"url cannot be empty\"));\n          return;\n        }\n        const formData = new import_form_data.default();\n        formData.append(\"url\", url);\n        this.sendRequest(formData).then((data) => {\n          const parsedData = ResponseSchema.parse(data);\n          resolve(parsedData);\n        }).catch((err) => {\n          reject(new Error(err?.toString()));\n        });\n      });\n    };\n    if (!(CF_ACCOUNT_ID && CF_API_TOKEN))\n      throw new Error(\"CF_ACCOUNT_ID or CF_API_TOKEN cannot be empty\");\n    this.CF_ACCOUNT_ID = CF_ACCOUNT_ID;\n    this.CF_API_TOKEN = CF_API_TOKEN;\n  }\n};\n","import FormData from \"form-data\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { z } from \"zod\";\nconst axios = require(\"axios\").default;\n\nconst ResultSchema = z.object({\n  id: z.string(),\n  filename: z.string(),\n  uploaded: z.string(), // Assuming date string format, you can specify a Date schema if required\n  requireSignedURLs: z.boolean(),\n  variants: z.array(z.string()),\n});\n\nconst ResponseSchema = z.object({\n  result: ResultSchema,\n  success: z.boolean(),\n  errors: z.array(z.unknown()), // Assuming errors can be of any type\n  messages: z.array(z.unknown()), // Assuming messages can be of any type\n});\n\ntype ParsedResponse = z.infer<typeof ResponseSchema>;\n\nexport default class Uploader {\n  private CF_ACCOUNT_ID: string;\n  private CF_API_TOKEN: string;\n\n  constructor(CF_ACCOUNT_ID: string, CF_API_TOKEN: string) {\n    if (!(CF_ACCOUNT_ID && CF_API_TOKEN))\n      throw new Error(\"CF_ACCOUNT_ID or CF_API_TOKEN cannot be empty\");\n    this.CF_ACCOUNT_ID = CF_ACCOUNT_ID;\n    this.CF_API_TOKEN = CF_API_TOKEN;\n  }\n\n  public fromBase64 = async (\n    base64Text: string,\n    filename: string = uuidv4(),\n    fileExtension = \"png\",\n  ): Promise<ParsedResponse> => {\n    return new Promise((resolve, reject) => {\n      if (!base64Text) {\n        reject(new Error(\"base64Text cannot be empty\"));\n        return;\n      }\n      if (base64Text.includes(\"base64\")) {\n        reject(new Error(\"Remove data:***/***;base64 tag from input.\"));\n        return;\n      }\n\n      const formData = new FormData();\n      formData.append(\n        \"file\",\n        Buffer.from(base64Text, \"base64\"),\n        `${filename}.${fileExtension}`,\n      );\n\n      this.sendRequest(formData)\n        .then((data) => {\n          const parsedData = ResponseSchema.parse(data);\n          resolve(parsedData);\n        })\n        .catch((err) => {\n          reject(new Error(err?.toString()));\n        });\n    });\n  };\n\n  private sendRequest = async (formData: FormData): Promise<unknown> => {\n    const options = {\n      method: \"POST\",\n      url: `https://api.cloudflare.com/client/v4/accounts/${this.CF_ACCOUNT_ID}/images/v1`,\n      headers: {\n        \"Content-Type\": \"multipart/form-data\",\n        Authorization: `Bearer ${this.CF_API_TOKEN}`,\n      },\n      data: formData,\n    };\n    return (await axios.request(options))?.data;\n  };\n\n  public fromURL = async (url: string): Promise<ParsedResponse> => {\n    return new Promise((resolve, reject) => {\n      if (!url) {\n        reject(new Error(\"url cannot be empty\"));\n        return;\n      }\n      const formData = new FormData();\n      formData.append(\"url\", url);\n      this.sendRequest(formData)\n        .then((data) => {\n          const parsedData = ResponseSchema.parse(data);\n          resolve(parsedData);\n        })\n        .catch((err) => {\n          reject(new Error(err?.toString()));\n        });\n    });\n  };\n}\n"]}